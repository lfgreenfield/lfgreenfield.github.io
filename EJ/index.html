<!DOCTYPE html>
<html>

<head>
    <meta charset=utf-8 />
    <title>KFTC</title>
    <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />    
    <script src="http://cdn.leafletjs.com/leaflet-0.7.3/leaflet.js"></script>
    <script src="https://cartodb-libs.global.ssl.fastly.net/cartodb.js/v3/3.15/cartodb.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simple-statistics/1.0.0/simple_statistics.min.js"></script>
    <script src="l.control.geosearch.js"></script>
    <script src="l.geosearch.provider.esri.js"></script>
     <script src="https://code.jquery.com/jquery-1.11.2.min.js"></script>

    <link rel="stylesheet" href="http://cdn.leafletjs.com/leaflet-0.7.3/leaflet.css" />
    <link href='http://fonts.googleapis.com/css?family=Lato' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="http://libs.cartocdn.com/cartodb.js/v3/3.15/themes/css/cartodb.css" />
    
  

    <style>
        body {
            margin: 0;
            padding: 0;
            background: whitesmoke;
            font-family: Lato, sans-serif;
            color: #0D0000;
        }
        header {
            position: absolute;
            height: 15%;
            width: 100%;
            background:rgba(25,25,25,0.8);
            border-bottom: 6px solid #66bd63;
        }
        h1 {
            display: inline-block;
            margin-right: 5px;
            color: #302725;
            font-family: sans-serif;
            font-size: .9em;
            position: absolute;;
            width: 300px;
            text-align: right;
            font-weight: 100;
            right: 15px;    
        }
        #map {
            position: absolute;
            z-index: 100;
            width: 100%;
            top: 16%;
            bottom: 0;
        } 
        .logo{
            width: 200px;
           
        }
        .leaflet-popup-content-wrapper {
            background: rgba(25,25,25,0.8);
            opacity: 0.95;
            border-radius: 5px;
            color: whitesmoke;
        }
        .leaflet-popup-tip {
            background: rgba(25,25,25,0.8);
            opacity: 0.8;
        }
        .leaflet-control-layers-expanded {
            border-radius: 0px;
            background: rgba(25,25,25,0.8);
            color: whitesmoke;
            width: 160px;
        }
        .leaflet-top .leaflet-control {
                margin-top: 0.5px;
            }
        .leaflet-container {
            font-family: Lato, sans-serif;
            font-size: 1em;
        }
          .legend {
            padding: 6px 8px;
            font-size: 1em;
            background: rgba(75,75,75,0.8);
            color: whitesmoke;
            box-shadow: 0 0 15px rgba(0,0,0,0.2);
            border-radius: 5px;
            width: 160px;
        }
        .legend h3 {
            font-size: 1.1em;
            font-weight: bold;
            line-height: 1em;
            color: whitesmoke;
            margin: 0;
        }
        .legend li {
            list-style-type: none;
            height: 22px;
        }
        .legend span {
            width: 30px;
            height: 20px;
            float: left;
            margin-right: 10px;
        }
  
    </style>
    
</head>

<body>  
    <header>
        <a href="http://kftc.org/empowerky"><img src ="kftc.png" alt="LOGO" class='logo'></a>
        <h1>Environmental Justice Analysis.</h1>
    </header>
    
    
    <div id='map'></div>
    
    </div>
 
    <script src="powerplants.js"></script>
    <script src="county_data.js"></script>


        
<script> 
        
        var options = {
            center: [37.6456, -84.7697],
            zoom: 7,
            dragging: true,
            zoomControl: true
        }
        var map = L.map('map', options);
       
        var tiles =  L.tileLayer('http://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
        attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
        });
    
        map.addLayer(tiles);  
    
        // add search box    
        new L.Control.GeoSearch({
            provider: new L.GeoSearch.Provider.Esri(),
            position: 'topright',
            zoomLevel: 10,
            showMarker: true,
            showPopup: false,
            marker: {
                draggable: false
            }
        }).addTo(map);

//    
//        L.Control.Watermark = L.Control.extend({
//            onAdd: function(map) {
//                var img = L.DomUtil.create('kftc');
//
//                img.src = 'kftc.png';
//                img.style.width = '200px';
//
//                return img;
//            },
//
//            onRemove: function(map) {
//                // Nothing to do here
//            }
//        });
//
//        L.control.watermark = function(opts) {
//            return new L.Control.Watermark(opts);
//        }
//
//        L.control.watermark({ position: 'bottomleft' }).addTo(map);
                    
      // load, symbolize, add Cumulative Pollution layer
        var sql = new cartodb.SQL({ user: 'lfgreenfield', format: 'geojson' });

        sql.execute("SELECT * FROM cumulativepollution").done(function(geojson) {

            // get pollution data
            var pollution = L.geoJson(geojson);

            pollution.eachLayer(function(layer){

                layer.setStyle({

                    fillColor: getGridColor(layer.feature.properties.gridcode),
                    opacity: 0,
                    fillOpacity: 1

                });
            })

            pollution.addTo(map);
            
        
             var pollutionControl = {"Cumulative Pollution": pollution}
//            
            L.control.layers(null, pollutionControl, { collapsed:false }).addTo(map);


        })
        
        //load, symbolize, make county data (percents and boundaries) stay on top        
        sql.execute("SELECT * FROM pov_percencounty").done(function(geojson){
            
            var county_data = L.geoJson(geojson);
            
            county_data.eachLayer(function(layer){
             layer.setStyle({
                    opacity: 1,
                    fillOpacity: 0,
                    weight: 0.8
                })
                layer.on('mouseover', function() {
                    layer.setStyle({
                        color: 'yellow',
                        weight: 3
                    });
                    layer.bringToFront();
                    
                    var props = layer.feature.properties;
                
                    var content = layer.feature.properties["name"]+" County"+"<br>"+"Poverty: "+props["pctpov"]+"%"+"<br>"+"Minority: "+props["pctminor"]+"%";
                    layer.bindPopup(content,{
                    });
                    
                    layer.openPopup();
                    
                })
                layer.on('mouseout', function(){
                    layer.setStyle({color: 'blue', weight: 0.8});
//                    layer.closePopup();
                });
                
//                var props = layer.feature.properties;
//                
//                var content = layer.feature.properties["name"]+" County"+"<br>"+"Poverty: "+props["pctpov"]+"%"+"<br>"+"Minority: "+props["pctminor"]+"%";
//                layer.bindPopup(content);

            })
                
            county_data.addTo(map);
            
//            L.marker([data.data[i].lat,data.data[i].lng], {icon:icon}).bindPopup(content, {closeButton: false, keepInView: true}).on('mouseover',function(e){this.openPopup()}).on('mouseout', function(e){this.closePopup()}).addTo(map);
            
                      
            map.on("overlayadd", function (event) {
                county_data.bringToFront();
            });
      
        })
 
    // get pov and minor layers and send to drawMap        
        var minorityLayer = L.geoJson(county_percents);
        drawMap(minorityLayer, "PctMinor");
        console.log(minorityLayer);
        
        var povertyLayer = L.geoJson(county_percents);
        drawMap(povertyLayer, "PctPov");
        
    
        makeLayerSelector(minorityLayer, povertyLayer);
        

    
    
        function makeLayerSelector(minorityLayer, povertyLayer){
            
            //first get powerPlantLayer
            var powerPlantLayer = L.geoJson(powerPlants, {

                pointToLayer: function(feature){
                    var latlng = L.latLng(feature.properties.Latitude, feature.properties.Longitude);
                    var icon = L.icon({
                        iconUrl: 'powerplant.png',
                        iconSize:     [25, 25], // size of the icon
                        iconAnchor:   [12,12], // point of the icon which will correspond to marker's location
                        popupAnchor:  [6, -20] // point from which the popup should open relative to the iconAnchor
                    });

                    return L.marker(latlng, {icon:icon});
                }

             }).addTo(map);
            
                   
            // make selector
                var controls = {
                    "Poverty": povertyLayer, 
                    "Minority": minorityLayer,
                    "Power Plants": powerPlantLayer

                };

                L.control.layers(null, controls, { collapsed:false }).addTo(map);
            
            map.on('layerchange', function(){
                console.log("we changed");
            })
            

        }
//    map.on('baselayerchange', function (eventLayer) {
//    if (eventLayer.name === 'Poverty') {
//        console.log('now we are looking at poverty');
////        map.removeControl(currentLegend );
////        currentLegend = SGlegend;
////        SGlegend.addTo(map);
//    }
//    else if  (eventLayer.name === 'Minority') {
//        console.log('now we are looking at MINORITY');
////        map.removeControl(currentLegend );
////        currentLegend = BUDlegend;
////        BUDlegend.addTo(map);
////    }
////    else if  (eventLayer.name === 'Forest') {
////       map.removeControl(currentLegend );
////        currentLegend = LISlegend;
////        LISlegend.addTo(map);
////    }
////    else if  (eventLayer.name === 'Water') {
////       map.removeControl(currentLegend );
////        currentLegend = VODlegend;
////       VODlegend.addTo(map);
////    }
//  
//    }
//    })
          

    //function drawMap to colorize pov and minor and add to map        
        function drawMap(dataLayer, attribute){
            
            var breaks = getClassBreaks(dataLayer, attribute);
//            console.log(breaks);
            
            dataLayer.eachLayer(function(layer){
                
                var props = layer.feature.properties;
                
                layer.setStyle({
                    fillColor: getColor(props[attribute], breaks),
                    opacity: 0,
                    fillOpacity: 1
                })
            })
            
         
    
            
            //not adding to map bc not automatically selected in layer control!
                            
//            dataLayer.addTo(map);
            
        }
            
        
        function getGridColor (gridcode) {
             
                if(gridcode == 1) {
                    return '#006837';
                } else if(gridcode == 2) {
                    return '#1a9850';
                } else if(gridcode == 3) {
                    return '#66bd63';
                } else if(gridcode == 4) {
                    return '#a6d96a'
                } else if(gridcode == 5) {
                    return '#d9ef8b'
                } else if(gridcode == 6) {
                    return '#fee08b'
                } else if(gridcode == 7) {
                    return '#fdae61'
                }  else if(gridcode == 8) {
                    return '#f46d43'
                }  else if(gridcode == 9) {
                    return '#d73027'
                }  else if(gridcode == 10) {
                    return '#a50026'
                }
            
        }
        
        function getClassBreaks(dataLayer, attribute) {
            
            //  create array 'values'
            var values = [];
            
            // for each layer, create normalized value and push into array 'values'
            dataLayer.eachLayer(function(layer) {
                var value = layer.feature.properties[attribute];
                values.push(value);   
            }); 
           
            // use simple statistics ck means to divide array 'values' into 5 groups/arrays, make 'clusters' which is an array of arrays
            var clusters = ss.ckmeans(values, 10);
            // assign highest and lowest value from each of 10 arrays within 'clusters' array to the var 'breaks' 
            var breaks = clusters.map(function(cluster){
                return [cluster[0],cluster.pop()];   
            });
            // return 'breaks' with highest and lowest values from each of 10 groups to functions where getClassBreaks/'breaks' are called
            return breaks;
            
        }  
        
        // send d (attribute) and breaks
         function getColor(d, breaks) {
            
            if(d <= breaks[0][1]) {
                return '#006837';
            } else if(d <= breaks[1][1]) {
                return '#1a9850';
            } else if(d <= breaks[2][1]) {
                return '#66bd63';
            } else if(d <= breaks[3][1]) {
                return '#a6d96a'
            } else if(d <= breaks[4][1]) {
                return '#d9ef8b'
            }
             else if(d <= breaks[5][1]) {
                return '#fdae61'
            }
               else if(d <= breaks[6][1]) {
                return '#f46d43'
            }
               else if(d <= breaks[7][1]) {
                return '#BD0026'
            }
               else if(d <= breaks[8][1]) {
                return '#d73027'
            }
               else if(d <= breaks[9][1]) {
                return '#a50026'
            }
         }        
 

//    function drawLegend() {
//            
//            //set control position
//            var legend = L.control({position: 'bottomright'});
//            
//            //cues for when legend is adding to map: div created
//            legend.onAdd = function(map) {
//                
//                var div = L.DomUtil.create('div', 'legend');
//               
//                return div;
//            };
//           
//            //adding legend to map
//            legend.addTo(map);
//        }
//  
//  
    
    
     
        

    </script>
    
</body>

</html>